Разработчики корутин хотели, чтобы код выглядел синхронным, но по своей сути он остаётся асинхронным.
В основе корутин лежат обратные вызовы из другого или того же самого потока.

# Structured Concurrency - Структурированный параллелизм
1) Корутины должны быть созданы и запущены внутри области с определенным жизненным циклом.
   Это означает, что если нам больше не нужна область(вернулись на предыдущий экран, например), вся корутины области
   должны быть отменены.
2) Все корутины имеют иерархию. На вершине родительский объект Job scope.
3) При отмене родительской корутины, отменяются и дочерние.
4) Родительская корутина не завершает работу, пока все её дочерние корутины не завершат работу.
5) Отмена дочерней корутины не влияет на родительскую
6) Если в дочерней корутине было брошено исключение, то оно передаётся родительский объектам

# Scope
Корутины запускаются в определенной области видимости - Scope. Scope создаётся из CoroutineContext.

# Coroutine context
CoroutineContext - это составной объект:
1) CoroutineName
2) Dispatcher
3) Job
4) CoroutineExceptionHandler

# Dispatcher: подготовка к пониманию.
# Executor Service
Создание потока - это дорогое удовольствие(по ресурсам и времени), поэтому используют ограниченное количество потоков.
ExecutorService - это очередь задач + стратегия в отношении потоков (фиксированное количество, динамическое)
Выполняемые задачи организуются в очереди и отдаются потокам.
ExecutorService также решает вопрос управления жизненным циклом потоков(отмена задач в потоках).

Три основных ExecutorsService:
1) FixedThreadPool - фиксированное количество потоков.
   Используется для трудоёмких задач.
   Чтобы ресурс ядра процессора не тратился на переключение между потоками, лучше использовать количество потоков равное
   количеству ядер.
2) SingleThreadExecutor - один поток.
   UI Android использует SingleThreadExecutor. Работа с пользовательским интерфейсом.
3) CachedThreadPool
   Для задач с сетью, чтение и запись в файл лучше подходит CachedThreadPool

# Непосредственно Dispatcher
Стандартные Dispatchers:
1) Dispatcher-Default использует пул потоков фиксированной длины с небольшой адаптацией, равной количеству физических
   ядер процессора.
2) Dispatcher-Unconfined запускает корутину в потоке на котором её создали, но после приостановки дальнейший поток
   выполнения зависит от контекста, который использует suspend-функция. Если suspend-функция не меняет контекст, то
   корутина продолжит выполняться в том же потоке. Если suspend-функция использует другой Dispatcher корутина сменит
   поток.
3) Dispatcher-IO использует CachedThreadPool. Используется для несложных операций, но где нужно ждать другие системы:
   чтение файлов, запись в файлы, чтение и запись в базу данных.
4) Dispatchers-Main использует SingleThreadExecutor

Все стандартные Dispatchers используют потоки-демоны. Можно сделать свой Dispatcher из ExecutorService с основным
потоком:
private val dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher()
private val scope = CoroutineScope(dispatcher)

# Job
Job в корутин-контексте - это родительский для всех корутин скоупа объект, родительская корутина. Сами корутины являются
Job.
Родительская корутина может быть Job или SuperVisedJob. Отличие лишь в том, что с Job, если дочерняя корутина завершится
с ошибкой, то весь Scope становится неработоспособным, все корутины отменяются, а с SuperVisedJob скоуп остаётся живым и
другие дочерние корутины не затрагиваются.

# CoroutineExceptionHandler и исключения в корутинах
Если в дочерней корутине было брошено исключение, то оно попадает в родительский Job.

CoroutineExceptionHandler не спасает Job от становления непригодным и никак не влияет на работоспособность
SuperVisedJob.
В SuperVisedJob ошибка никак не влияет на жизнь потока.

Если мы используем Job, как корутину родитель, то все текущие и будущие корутины отменяются при ошибке в одной из них,
независимо от того, есть
или нет ExceptionHandler в scope. Если используем SuperVisorJob, то весь scope остаётся пригодным для текущего и
будущего использования.

Передача ExceptionHandler в дочернюю корутину игнорируется

Если использовать async, то ошибка не отобразится, т.к. останется внутри deffered, но скоуп обрушит в случае с Job. Если
у Deffered использовать await, то тогда ошибка дойдёт до корня.

Если запустить async внутри launch, то в этом случае ошибка в корневую Job дойдёт, даже без вызова await.

# Отмена корутин
Coroutine.cancel() делает из active корутины inactive. Это всё, что делает cancel.
Ответственность за завершение корутины (обработки флага isActive) лежит на авторе корутины и suspend функции.
Это сделано для того, чтобы в процессе сложных операций данные не повредились.
Чтобы завершить корутину надо бросить CancellationException, если корутина не активна. Это можно сделать с помощью
ensureActive()

Правило: если suspend функция обёрнута в try catch, то нужно пробрасывать дальше CancellationException, чтобы механизм
отмены корутин работал.
Правило: Если мы создаём свою suspend функцию, то она должна поддерживать механизм отмены корутин.
У функции delay есть такая поддержка, поэтому CancellationException бросается.

Отмена scope не завершает потоки, если хотя бы одна корутина была запущена на Dispatcher без демон потоков. Только
закрытие Dispatcher закроет открытые потоки и программа завершится.

# Строители корутин
1) scope.launch {} - создаёт корутину без результата
2) scope.async {} - создаёт корутину из которой можно получить результат через suspend функцию await, вызванного у
   объекта Deferred.
3) runBlocking {} - блокирует поток, из которого запущена корутина, пока корутина не будет завершена. используется в
   тестах и как функция main.

# Suspend функции
1) suspendCoroutine {} - используется для создания suspend функции из функции с callback
2) coroutineScope {} - создаёт скоуп с Job, освобождает поток, пока не будет завешена полностью
3) supervisedScope {} - создаёт скоуп с SupervisedJob, освобождает поток, пока не будет завешена полностью

```
private suspend fun loadBook(): Book = suspendCoroutine { continuation ->
    loadBook { continuation.resumeWith(Result.success(it)) }
}
```
