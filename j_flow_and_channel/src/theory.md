# Потоки
Thread - поток исполнения программы
InputStream, OutputStream - потоки байтов
Flow - поток данных (объектов)

# Признаки потока данных
1) Промежуточные операторы производят последовательную(по одному) обработку элементов.
2) Возможность прекратить обработку данных, когда элементы больше не требуются.
3) Пока не вызван терминальный оператор, промежуточные выполняться не будут.
   Терминальный оператор является завершающим и он же запускает поток на выполнение.
   Промежуточные операторы не запускают поток и ничего не делают, пока нет терминального оператора.

# Коллекции
1) Промежуточные операторы производят обработку всех элементов сразу.
2) Нет возможности прекратить обработку данных, на всех этапах данные обработаются.
3) Отсутствие терминальный оператора не влияет на выполнение промежуточных

# Sequence
Синхронный поток данных, выполняется на одном потоке.
yield - выпустить в поток данные.
forEach - операция для каждого элемента потока, терминальный оператор.

# Flow
Асинхронный поток данных.
Внутри функции flow может выполнять любые suspend функции. Завершения корутин внутри себя не ждёт.
Все терминальные операторы являются suspend функциями.
вместо yield() emit()
вместо forEach{} collect {}

# Channel
Это очередь данных. Она нужна для общения корутин между собой.
Producer может добавить значение в эту очередь, а Consumer потреблять эту очередь.
send()
consumeEach()
catch() не спасает поток, если ошибка произошла в промежуточном операторе

```kotlin
// consumeAsFlow:
flow<String> {
   queries.consumeEach {
      emit(it)
   }
}
```

# Холодные поток
`flow{}`, `Flow`
1) Холодный поток не начнёт выпускать данные, пока на него не подпишутся.
2) Если данные больше не нужны, холодный поток завершает свою работу
3) Если холодный поток закончил выпускать значения, то его коллекторы завершают работу.
4) Если подписаться на один и тот же холодный flow, то создаются новые потоки данных для каждого коллектора, то есть,
   flow начинает работать сначала.
5) emit можно вызвать только внутри flow {}
# Горячий поток
`MutableSharedFlow()`, `SharedFlow`,
1) Горячий поток выпускает данные независимо от наличия подписчиков.
2) Если данные больше не нужны, горячий поток не завершает работу.
3) Коллекторы горячего потока завершают работу, только если им больше не нужны данные (take())
4) Для каждого подписчика горячий поток один и тот же.
5) emit можно вызвать снаружи
6) Горячий поток никогда не завершает работу

# ShareIn
```kotlin
private val timerFlow = generateSequence(0) { it + 1 }.asFlow().onEach { delay(1000) }
private val timerShared = timerFlow.shareIn(scope, SharingStarted.Eagerly)
//private val timerShared = MutableSharedFlow<Int>().apply {
//    scope.launch {
//        timerFlow.collect {
//            emit(it)
//        }
//    }
//}.asSharedFlow()
```
`SharingStarted.Eagerly` - поток начинает выпускать значения сразу после создания.  
`SharingStarted.Lazily` - поток начинает выпускать значения только после первой подписки.  
`SharingStarted.WhileSubscribed()` - поток начинает выпускать значения после первой подписки, до тех пор
пока есть подписчики. Когда подписчиков нет, подписка на холодный поток внутри shareIn отменяется. А при новых
подписчиках холодный поток стартует заново.

# BackPressure and Buffer
BackPressure - ситуация, когда Producer выпускает данные быстрее, чем Consumer успевает их обработать.
В стандартной реализации холодного потока Producer приостанавливает выпуск новых значений, пока Consumer, не обработает
старое.  
`buffer()` позволяет изменить это поведение. `capacity` позволяет задать размер `buffer`, по умолчанию 64 элемента.
и можно выбрать стратегию - что делать, когда `buffer` переполнен:

`SUSPEND` - приостановить выпуск новых значений, пока место в `buffer` не освободится.  
`DROP_OLDEST` - выбросить самое старое значение в `buffer`, и положить новое.
`DROP_LATEST` - выбросить самое новое значение в `buffer` и положить новое.

Интересно, что будет, если это будет с sharedFlow

