# Потоки
Thread - поток исполнения программы
InputStream, OutputStream - потоки байтов
Flow - поток данных (объектов)

# Признаки потока данных
|                                                                 | Поток данных    | Коллекция       |
|-----------------------------------------------------------------|-----------------|-----------------|
| Коллекция данных проходит через промежуточный оператор          | одним элементом | всей коллекцией |
| Возможность прекратить обработку данных, если данные не нужны   | есть            | нет             |
| Пока не вызван терминальный оператор, промежуточные выполняться | не будут        | будут           |
| Терминальный оператор является завершающим и запускает поток    | да              | нет             |

# Sequence and Flow
|                        | Sequence         | Flow                     |
|------------------------|------------------|--------------------------|
| Синхронность           | Синхронный       | Асинхронный              |
| Выпуск данных          | `yield()`        | `emit()`                 |
| suspend функции внутри | только местные   | любые                    |
| терминальный оператор  | `fun forEach {}` | `suspend fun collect {}` |

# Channel
Это очередь данных.  
Нужна для общения корутин между собой.  
Producer может добавить значение в эту очередь.  
Consumer потреблять эту очередь.  
`consumeAsFlow()` может быть вызвана только один раз
`receiveAsFlow()` может быть вызвана много раз
`send()`
`consumeEach()`
```kotlin
// consumeAsFlow:
flow<String> {
    channel.consumeEach {
        emit(it)
    }
}
```

# Холодные поток и Горячий поток

|                             | Холодный `flow{}` `Flow`         | Горячий `MutableSharedFlow()` `SharedFlow`      |
|-----------------------------|----------------------------------|-------------------------------------------------|
| Поток выпускает данные      | начинает в момент подписки       | независимо от наличия подписчиков               |
| Если данные больше не нужны | завершает работу                 | не завершает работу никогда                     | 
| Коллектор завершает работу  | когда поток завершил работу      | только если им больше не нужны данные, `take()` |
| Второй коллектор            | начинает получать данные сначала | получает только новые данные                    |
| `emit()` можно вызвать      | только внутри flow {}            | снаружи                                         |

# ShareIn
- делает из холодного потока горячий
```kotlin
private val timerFlow = generateSequence(0) { it + 1 }.asFlow().onEach { delay(1000) }
private val timerShared = timerFlow.shareIn(scope, SharingStarted.Eagerly)
//private val timerShared = MutableSharedFlow<Int>().apply {
//    scope.launch {
//        timerFlow.collect {
//            emit(it)
//        }
//    }
//}.asSharedFlow()
```
`SharingStarted.Eagerly` - поток начинает выпускать значения сразу после создания.  
`SharingStarted.Lazily` - поток начинает выпускать значения только после первой подписки.  
`SharingStarted.WhileSubscribed()` - поток начинает выпускать значения после первой подписки, до тех пор
пока есть подписчики. Когда подписчиков нет, подписка на холодный поток внутри shareIn отменяется. А при новых
подписчиках холодный поток стартует заново.

# BackPressure and Buffer
BackPressure - ситуация, когда Producer выпускает данные быстрее, чем Consumer успевает их обработать.
В стандартной реализации холодного и горячего потока Producer приостанавливает выпуск новых значений, пока Consumer, не
обработает старое.
`buffer()` позволяет изменить это поведение.  
`capacity` позволяет задать размер `buffer`, по умолчанию 64 элемента.

Можно выбрать, что делать, когда `buffer` переполнен:
`SUSPEND` - приостановить выпуск новых значений, пока место в `buffer` не освободится.  
`DROP_OLDEST` - выбросить самое старое значение в `buffer`, и положить новое.
`DROP_LATEST` - выбросить самое новое значение в `buffer` и положить новое.

# Shared Flow vs StateFlow
`replay` - количество элементов, которые нужно хранить Shared Flow для того, чтобы отдавать подписчикам в момент
подписки.  
`extraBufferCapacity` - размер буфера дополнительно к размеру `replay`. По умолчанию 0.  
State Flow - это `SharedFlow`, с параметрами `replay` = 1, `extraBufferCapacity` = 0, `onBufferOverFlow` = DROP_OLDEST,
а также с `distinctUntilChanged()`. Все эти параметры нельзя изменить.

|                             | Shared                          | State                          |
|-----------------------------|---------------------------------|--------------------------------|
| `replay`                    | 0, можно изменить               | 1, нельзя изменить             |
| `extraBufferCapacity`       | 0, можно изменить               | 0, нельзя изменить             |
| `onBufferOverFlow`          | `SUSPEND`, можно изменить       | `DROP_OLDEST`, нельзя изменить |
| `distinctUntilChanged()`    | не вызван                       | вызван, нельзя изменить        |
| требует начальное значение  | нет                             | да                             |
| `tryEmit()`                 | требует изучения свойств потока | может применяться спокойно     |
| `getValue()`, `setValue()`  | нет                             | есть                           |
| функция преобразование х.п. | `shareIn()`                     | `stateIn()`                    |

# Исключения

`catch()` ловит исключения выброшенные внутри flow генератора и промежуточных операторах.
Поток заканчивает работу. Чтобы работа потока продолжилась, нужно в генераторе и в промежуточных операторах
оборачивать опасную операцию.

`retry()` повторяет flow сверху указанное количество раз, если выброшено исключение вверху потока.

Ошибка пойманная через catch не обрушивает scope, он остаётся работоспособным.

suspend `emit` -> suspend  `collect` -> stop suspend `emit`

# Flow On
Все emit, промежуточные операторы будут выполняться на том dispatcher, на котором была произведена подписка.
`flowOn()` - влияет только на часть потока выше оператора на upstream

# Mutex вместо synchronized
В блоке synchronized нельзя использовать suspend функции.

|                      | synchronized           | withLock                  |
|----------------------|------------------------|---------------------------|
| поток                | блокирует поток        | приостанавливает корутину |
| suspend внутри блока | -                      | +                         |
| снятие замка         | поток, закрывший замок | корутина, закрывшая замок |